# Eventual consistency

Teacher talked about that besides de other differences, one difference in relation to SQL databases is related to consistency. Imagine a RDBMS relational traditional SQL server cluster. When a new information need to be replicated, it needs to be replicated in time it is be inserted and in a NoSQL world this is not a constraint. Maybe when you get an information, maybe this information is different in another server because it was not replicated yet. This is called eventual consistency.


# Differences between SQL ans NoSQL databases

![differences](images/differences-between-sql-and-nosql-databases.png)


# A advantages and disadvantages

![advantages](images/advantages.png)

![disadvantages](images/disadvantages.png)

!
# Key-value type of NoSQL databases

![key value](images/key-value-type.png)

Characteristics:

- Quick because the access is based in the desired key and because this databases works in memmory;
- Good for horizontal scaling;
- Example of use: session management, pub/sub systems and cache;


# Document type of NoSQL databases

![differences](images/document-type.png)

Characteristics:

- Does not demand a rigid structure of the data;
- Easy edition of the schema based on the user document;
- Efficient queries;
- Complex data modeling;
- Used as example on e-commerce catalogs because the schema can vary, different informations (structure) can be stored.


# Column type of NoSQL databases

![column type](images/column-type.png)

Characteristics:

- Good for horizontal scaling;
- Flexible schema;
- Efficient data retrieve;
- Used as example in logs.


# Graph type of NoSQL databases

![graph type](images/graph-type.png)

Characteristics:

- The relation in data is so important as the data. As example in social networks. This way we can search in a optimized way the friends in common in social networks.


# MongoBD

Teacher talked about aggregation pipelines, that this is a more complex subject.

Summary of MongoDB:

![summary of MongoDB](images/summary-mongodb.png)

Advantages of MongoDB:

![advantages of MongoDB](images/advantages-of-mongodb.png)

Disadvantages of MongoDB:

![disadvantages of MongoDB](images/disadvantages-of-mongodb.png)

Uses of MongoDB:

![uses of MongoDB](images/uses-of-mongodb.png)

Example of use case: geolocalizaition systems.

[External reference documentation](https://www.mongodb.com/pt-br/docs/manual/introduction/)

An external reference is showed [here](https://github.com/andreterceiro/dio-claro-spring--nosql-studies?tab=readme-ov-file#document-based). I elaborated this document when I was studying a content of a Java Spring bootcamp.

Teacher showed us [here](https://web.dio.me/course/introducao-a-banco-de-dados-nosql/learning/42c36130-0720-4981-b02f-a175825cc18a?back=/track/formacao-kotlin-backend-developer&tab=undefined&moduleId=undefined) an alternative to install MongoDB using [this link](http://cloud.mongodb.com). I showed other alternatives in [this document](https://github.com/andreterceiro/dio-claro-spring--nosql-studies?tab=readme-ov-file#document-based).

In the installation using http://cloud.mongodb.com, teacher showed us that there is a block of access based on the IP of the machine, but the IP of our machine is automatically added to allow access:

![allowing access from external hosts](images/allowing-access-from-external-hosts.png)

The minor structure of a MongoDB cluster in MongoDB Cloud is formed by 3 nodes.

An interesting part of the MongoDB Cloud is the observability part that came by default:

![MongoDB Cloud Observability](images/mongodb-cloud-observability.png)

We have to remember the basic structure. MongoDD does not have tables. A **database** is formed by **collections**. A **collection** is formed by **documents**. The documents do not need to have the same structure.

Rules related to MongoDB:

![rules related to MongoDB](images/mongodb-rules.png)

The identifier of a document in a collection (_id) can be generated by MongoDB.

Data types in MongoDB:

![data types in MongoDB](images/mongodb-datatypes.png)

Object ID is the information that is automatically inserted in the "**_id**" field.

MongoDB complex data types:

![MongoDB complex data types](images/mongodb-complex-data-types.png)

MongoDB has relationships. This is right. But MongoDB does not have referential integrity. Using references will allow us to make searches similar to use a join in a SQL database.

Although the field "**_id**" can be automatically generated, we can easily specify its value, see:

```
> db.banana.find({});
{ "_id" : ObjectId("67005ff16a36c359666484c9"), "age" : 43 }
{ "_id" : ObjectId("6760350eb46b9e5a224b1e10"), "age" : 42 }
{ "_id" : ObjectId("6760370e72173fe04aa8431b"), "name" : "Jefinho" }
> db.banana.insertOne({"_id": 1, "nome": "Enzo"})
{ "acknowledged" : true, "insertedId" : 1 }
> db.banana.find({});
{ "_id" : ObjectId("67005ff16a36c359666484c9"), "age" : 43 }
{ "_id" : ObjectId("6760350eb46b9e5a224b1e10"), "age" : 42 }
{ "_id" : ObjectId("6760370e72173fe04aa8431b"), "name" : "Jefinho" }
{ "_id" : 1, "nome" : "Enzo" }
```

Here teacher showed us how to make an insertion in MongoDB:

![insertion in MongoDB](images/simple-insert-01-in-mongodb,png)

As you can see in the previous image, we can see an example of inserting of an array an an example of inserting a document inside another document. 

Example of how to insert a GeoJSON:

![GEO JSON in MongoDB](images/geojson-mongodb.png)

Exernal references:

![external references related to MongoDB](images/external-references-mongodb.png)

Teacher teached us that the question of scalability related to MongoDB is interfered by the data modeling that you defined.
 
Teacher teached that the modeling must be based on the queries that be done more frequently.

Teacher also talked that the strategy of data modeling depends on the searches that will bo done and the strategy of updating the documents. Maybe you will not normalize your data, maybe have information duplicated in differents documents beacuse you want to optimize queries and use sub documents. But you can also think if it will create a problem to update the documents.

![inner documents in MongoDB](images/inner-documents-mongodb.png)

Here teacher showed an example of a document in MongoDB. As you can see in the next image, "reservas" is a inner document while "destino" is a reference for another document. Observsations:
- She justified that a "destino" could exists independent of a "reserva", so this make sense to be stored in an external document;
- In the other hand, is different to "reserva" case, that makes sense to be an inner document.

![example of document in MongoDB](images/example-of-document-mongodb.png)

Signals that you have to use inner documents in MongoDB:

![MongoDB - when use inner documents](images/mongodb-when-use-inner-documents.png)

Teacher commented in relation to 1:N relationship in the slide that differ from a N:M relationship, where many document are related to many other documents.

When not to use inner documents: when a document is accessed independent of the "father" document.

See another strategy in relation to the data modeling in MongoDB:

![mongodb relationship another strategy](images/mongodb-relationship-another-strategy.png)

See, in this strategy independent of a user that may have many reservation, we have a reservation pointing to an user.

One comment about the **use** clausule of MongoDB: you can select a database with this clausule or if a database does not exists, a new database will be created.

As teacher explained, in the client MongoDB compass a database will be showed only if it has 1 collection.

You can see the shell to interact with the database clicking in the arrow in the bottom of the next screen:

![MongoDB Compass - shell](images/shell-in-mongodb-compass.png)

If you insert a document (example: using db.{collection-name}.insertOne()) a collection will be created if it does not exists.

Finding documents:

![finding documents](images/finding-documents.png)

About **update()**, **updateOne()** and **updateMany()** MongoDB methods: "updateMany() : It update all documents in a collection with matching filter. updateOne() : It update only one top most document in a collection with matching filter. update() : By default, the update() method updates a single document.". [Reference](https://www.quora.com/What-is-the-difference-between-update-updateOne-and-updateMany-in-MongoDB#:~:text=updateMany()%20%3A%20It%20update%20all,method%20updates%20a%20single%20document

We do not have only **$set** available on updating documents. We have **$inc**, **$mul**, **$min**, **$max** or **$push**. We can use $inc to increment a number, see:

![$inc](images/$inc-on-update-mongodb.png)

And with **$push** we can add elements to an array. Important: we do not have to provide an array. We need to provide only the element to be added to the array.


## Operators


### Equality

Use this format:

```
db.usuarios.find({"endereco.cidade": "SÃ£o Paulo"})
```


### Logical

- $and
- $or
- $not

You can use **$and** in this two ways:

```
db.usuarios.find({"nome": "Carlos", "idade": 33})
```

Or you can use this format. $or you specify in a similar way:
```
db.usuarios.find({$and: [{"nome": "Carlos", "idade": 33}]})
```


### Comparison

- $eq (==)
- $ne (!=)
- $gt (>)
- $gte (>=)
- $lt (<)
- $lte (<=)
- $in ([])
- $nin (![])

Example of use of **$ne**:

```
db.viagens.usuarios.find({$and: [{idade: {$ne: 20}, {nome: "Carlos"}}]})
```

Example of use **$gte**:

```
db.viagens.usuarios.find({idade: {$gte: 20}})
```

Example of use **$in**:

```
db.viagens.usuarios.find( {idade: {$in: [20, 30]} } )
```


## Projections

Define which fields we want to retrieve from a document. Like in a SQL "world":

select **nome**, **idade** from usuarios

Example:

db.viagens.usuarios.find({idade: {$in: [20, 30]}}, **{nome: 1}**)


## Sorting

You can order ascending or descending based on a field


## Limiting

You can limit the number of documents to retrieve.


## Pagination

You can paginate using **skip** (where to start, like fifth page) and **limit** (number of documents per page).

Example:

```
db.usuarios.find().skip(5).limit(10)
```


# Redis

Is a databas system that stores the information **in memmory**, used to **cache** as example. Speed is a characteristics of Redis.

![redis characteristics](images/redis-characteristics.png)

When the teacher talked about the flexible data structure, she talked about the capacity of Redis to store an array, a string or a number as example.

Comparing to document based, in this case the SGDB can store a document that have a key and a value. In a SGDB like Redis, the SGDB is based on a key and a value. In another words, the keys maybe have no relation, in a document based the keys are related based on the document itself.

As Redis have the **pub/sub** characteristic, if we make a **simple** comparison, we can define Redis as equivalent to pub/sub system, RabbitMQ as example.

Main uses of Redis:

![main uses of Redis](images/main-uses-of-redis.png)

Main commands of Redis:

![main commands of redis](images/main-commands-of-redis.png)

[Here](https://github.com/andreterceiro/dio-claro-spring--nosql-studies) in the section related to **"key-value"** I showed an example with Redis. I used several (not all) of these commands and others.

Also, teacher passed us the link "http://try.redis.io/". besides the link is offline nowdays, we can serach in Google using the string "try Redis".

There, teacher explained that we can use the "help" command parametrized, like:

```
HELP SET
```

Teacher also explanied that in Redis we can't find anything using the value setted, we need to use the key. Example:

```
SET nome "Enzo"
GET nome    
```

We can find for a key based on part of its name, see:

![keys command](images/keys-command-redis.png)

I will not repeat in this document things that I remember that I mentioned [in this document](https://github.com/andreterceiro/dio-claro-spring--nosql-studies). I ask you to see all the README.md in this link. I do not remember if I mentioned this information there: you can set a negative number to expire to delete a key. This is similar to use the command "del":

```
EXPIRE key_name -1
```

We can also use the command `incr`:

```
127.0.0.1:6379> set acessos 0
OK
127.0.0.1:6379> incr acessos
(integer) 1
127.0.0.1:6379> get acessos
"1"
127.0.0.1:6379> incr acessos
(integer) 2
127.0.0.1:6379> get acessos
"2"
```

See the return of the command `incr`. You do not need the get command, it already return the updated value.

The same idea can be applied to the command `decr`.

Redis does not take care of the case (uppercase/lowercase) of the **command** (like "`set`" or "`get`").

I used in Linux Mint the app `redis-cli` to interact with Redis. Please see [this link](https://github.com/andreterceiro/dio-claro-spring--nosql-studies) (section related to key-value systems) to see how to install it in your system.

You can abort Redis or close the terminal window, but the values is still there, see:

```
127.0.0.1:6379> lpush nomes "Julio" "Enzo" "Andre"
(integer) 3
```

abort

```
127.0.0.1:6379> lpush nomes "Julio" "Enzo" "Andre"
(integer) 6
127.0.0.1:6379> lrange nomes 0 -1
1) "Andre"
2) "Enzo"
3) "Julio"
4) "Andre"
5) "Enzo"
6) "Julio"
```

Another comment of the previous commands:
- **lpush** allows you to set the element of a list. The values needs to be specified separanting them by a space. Subsequent calls will not overwrite the previous values, but add new ones;
- **lrange** allows you to get the values of a list. The values will be returned using the LIFO idea. The first value returned is the last one added to the list. And you **must** specify the range of the indexes as the last parameter. You can  use negative values, as example -1 or -2.

To know the length of a list, you can use the command `llen`. Example:

```
127.0.0.1:6379> llen nomes
(integer) 6
```